---
title: prototype.js / 読む001
---

少しずつ読んでいってみる。非常に丁寧に読んでいってみる。

[Prototype JavaScript framework: Download Prototype](http://www.prototypejs.org/download)

ここらへんからダウンロード。使ってるソースは1.5.1.2


9行目〜Prototypeオブジェクト定義
================================================================================
いきなり。

変数にオブジェクトというものをつめる
--------------------------------------------------------------------------------
まずグローバルに `Prototype` って変数を宣言して、その中にオブジェクトを詰め込んでいる。

```javascript
var Prototyep ={};
```

中括弧二つで空のオブジェクトリテラルになる。

オブジェクトは連想配列だ
--------------------------------------------------------------------------------
`Javascript` のオブジェクトは基本的に内部が連想配列になっている。
なので、連想配列の記述法であるキーと値の組み合わせをコロンでつないだものをカンマ区切りで列挙することで簡単にオブジェクトを作ることができる。このようなオブジェクトの記述をJSON形式とか言ったりする。

オブジェクトの中にメンバを定義できれば記述法はなんでもいいのだが `prototype.js` ではこの流儀。

```javascript
var Prototype = {};
Prototype['hoge'] = 'ほげ';
Prototype['piyo'] = 'ぴよ';
```


```javascript
var Prototype = {hoge:'ほげ', piyo:'ぴよ'};
```

この二つは同じ。

10行目〜バージョン格納
================================================================================
まず `Version` を格納。外部のプログラムがバージョンを確認したいとき用でしょうか。
これで `Prototypeオブジェクト` が `prototype.js` においてどんな位置づけかわかってくるようなこないような。

```javascript
  Version: '1.5.1.2',
```

2行目〜オブジェクトにはオブジェクトを入れられる
================================================================================
次に `Browser` を定義。

ここで特徴的な記述は・・・キーと値の組み合わせの値の部分にまたキーと値組み合わせ群が入れ子の状態で入っているということ。

`Javascript` ではオブジェクトのメンバはなんでもOKなので、オブジェクトであるキーと値の組み合わせも入れ子状態で突っ込むことができる。

```javascript
  Browser: {
    IE:     !!(window.attachEvent && !window.opera),
    Opera:  !!window.opera,
    WebKit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
    Gecko:  navigator.userAgent.indexOf('Gecko') > -1 && navigator.userAgent.indexOf('KHTML') == -1
  },
```

12行目〜ブラウザにはクセがある
================================================================================
では `Browser` の中に定義されているキーと値を見ていく。ここからは `Prototypeオブジェクト` のメンバとでも呼ぶ。

ブラウザ名っぽいメンバになにやら論理演算した結果を突っ込むような記述になっている。
`windowオブジェクト` の何かを呼び出してandで演算したりしている。

その、いろいろな演算はブラウザの判定を行っているよう。ブラウザにはそれぞれ `Javascript` の実装においてクセがあるので、ここでそのクセを利用してのブラウザ判定ロジックとしているよう。

`IE` の `windowオブジェクト` には `opera` というメンバはない→これはOperaではない！　という感じでメンバや機能の存在をチェックして判定に利用している。

IEで・・・

```javascript
alert(Prototype.IE);
alert(Prototype.Opera);
```

なんてやると true → false とポップアップされる。

存在チェックのテクニック
--------------------------------------------------------------------------------
ここで比較の技法

```javascript
if(!hoge){}
```

のような記述が他のコードでもよく見られるが、こういう記述の場合はほとんど値の存在チェックとして使われている。

Javascriptでは

| 対象      | 意味                                     |
| --------- | ------------------------------------ |
| `undefined` | オブジェクトが未定義                 |
| `null`      | ヌルポ                               |
| `false`     | ブーリアンの `false`                    |
| `0`         | 数値がゼロ                           |
| `NaN`       | 「数値じゃないよ」エラーオブジェクト |
| ``''``        | 空文字                               |

とかを論理演算子で評価すると `false` と評価されることになっている

エクスクラメーションは右側を評価する単項論理演算子なので、`!hoge` の組み合わせだと「存在しなかったら `true` 」になる。
否定の論理演算子をブーリアンへのキャストへ利用しているわけ。
各存在チェックを行い最終的な答えを各キーの値として返すような仕組みになっている。

記述の中に二重否定している部分があるが、これは `undefined` 等を `false` と理解できない古いブラウザ対策らしく、いったん否定したものを否定して結果が正常に解釈されるようにする小ワザだそうだ。
モダンなブラウザには必要ないテクニック。

まとめ
================================================================================

初回からおなかいっぱい・・・盗めるテクニック

- 変数にはオブジェクトなら何でもつっこめる
- `Javascript`のオブジェクトは基本的に連想配列である
- 連想配列は `JSON` 形式で簡単に記述できる
- 一部の特殊な値はブーリアンじゃないのに論理演算することができる
- 否定の論理演算子はブーリアンへのキャストに使える
- 各ブラウザの `JavaScript` 実装にはクセがある

こんなもんでしょうか・・・理解が深まる。

